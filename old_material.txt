from .__init__ import *

def compute_trace(tensor):
	s = 0
	for i in range(np.size(tensor, axis=0)):
		s += tensor[i, i, ...]
	return s

def compute_deviatoric(tensor):
	trace = compute_trace(tensor) / 3.0
	dev = np.copy(tensor)
	for i in range(np.size(tensor, axis=0)):
		dev[i, i, ...] -= trace
	return dev

def compute_double_contraction(tensor_1, tensor_2):
	assert tensor_1.shape == tensor_2.shape, 'Array shapes must match'
	s = 0
	for i in range(np.size(tensor_1, axis=0)):
		for j in range(np.size(tensor_2, axis=0)):
			s += tensor_1[i, j,...]*tensor_2[i, j, ...]
	return s

def compute_norm_tensor(tensor):
	return np.sqrt(compute_double_contraction(tensor, tensor))

class material():

	def __init__(self):
		self.density = None
		self._has_uniform_density = False
		self.add_density(1.0, is_uniform=True) # By default
		return

	def set_scalar_property(self, inpt, is_uniform=False):
		if is_uniform:
			if np.isscalar(inpt):
				func = lambda args: inpt*np.ones(shape=args['shape_quadpts'])
			elif callable(inpt):
				func = lambda args: inpt(args)
			else:
				raise Warning('Not implemented')
		else:
			assert callable(inpt), 'Not implemented'
			func = lambda args: inpt(args)
		return func

	def set_tensor_property(self, inpt, shape_tensor=2, is_uniform=False):

		def create_multiarray_from_twoarray(inpt, shape_tensor, shape_quadpts):
			y = np.zeros(shape=(shape_tensor, shape_tensor, *shape_quadpts))
			for i in range(shape_tensor):
				for j in range(shape_tensor):
					y[i, j, ...] = inpt[i, j]
			return y

		if is_uniform:
			if np.isscalar(inpt):
				func = lambda args: create_multiarray_from_twoarray(inpt*np.eye(shape_tensor), shape_tensor, args['shape_quadpts'])
			elif isinstance(inpt, np.ndarray):
				func = lambda args: create_multiarray_from_twoarray(inpt, shape_tensor, args['shape_quadpts'])
			elif callable(inpt):
				func = lambda args: inpt(args)
			else:
				raise Warning('Not implemented')
		else:
			assert callable(inpt), 'Not implemented'
			func = lambda args: inpt(args)
		return func

	def add_density(self, inpt, is_uniform):
		if is_uniform: self._has_uniform_density = True
		self.density = self.set_scalar_property(inpt, is_uniform=is_uniform)
		return

class heat_transfer_mat(material):
	"""
	In our work we consider nonlinar materials, i.e. its thermal properties
	could change depending on the position, temperature, etc.
	"""
	def __init__(self):
		super().__init__()
		self.capacity     = None
		self.conductivity = None
		self._has_uniform_capacity     = False
		self._has_uniform_conductivity = False
		return

	def add_capacity(self, inpt, is_uniform):
		if is_uniform: self._has_uniform_capacity = True
		self.capacity = self.set_scalar_property(inpt, is_uniform=is_uniform)
		return

	def add_conductivity(self, inpt, is_uniform, shape_tensor):
		if is_uniform: self._has_uniform_conductivity = True
		self.conductivity = self.set_tensor_property(inpt, shape_tensor=shape_tensor, is_uniform=is_uniform)
		return

	def add_ders_capacity(self, inpt, is_uniform):
		self.ders_capacity = self.set_scalar_property(inpt, is_uniform=is_uniform)
		return

	def add_ders_conductivity(self, inpt, is_uniform, shape_tensor):
		self.ders_conductivity = self.set_tensor_property(inpt, shape_tensor=shape_tensor, is_uniform=is_uniform)
		return

class isotropic_hardening:
	def __init__(self, elastic_limit, iso_args:dict):
		self.elastic_limit = elastic_limit
		self.iso_hardening_function, self.iso_dershardening_function = self._select_model(iso_args)
		return

	def _select_model(self, iso_args):
		models = {
			"none": self._model_none,
			"linear": self._model_linear,
			"swift": self._model_swift,
			"voce": self._model_voce,
		}
		model_name = iso_args.get('name', 'none').lower()
		if model_name not in models: raise ValueError("Unknown hardening model")
		return models[model_name](iso_args)

	def _model_none(self, _):
		return lambda a: 1e6 * self.elastic_limit * np.ones_like(a), lambda a: np.zeros_like(a)

	def _model_linear(self, args:dict):
		Eiso = args.get('Eiso')
		return lambda a: self.elastic_limit + Eiso * a, lambda a: Eiso * np.ones_like(a)

	def _model_swift(self, args:dict):
		e0, n = args.get('e0'), args.get('n')
		return lambda a: self.elastic_limit * (1 + a / e0) ** n, lambda a: self.elastic_limit * n / e0 * (1 + a / e0) ** (n - 1)

	def _model_voce(self, args:dict):
		ssat, beta = args.get('ssat'), args.get('beta')
		return lambda a: self.elastic_limit + ssat * (1 - np.exp(-beta * a)), lambda a: ssat * beta * np.exp(-beta * a)

class kinematic_hardening:
	def __init__(self, kine_args:dict):
		chaboche_table = np.atleast_2d(kine_args.get('parameters', [[0, 0]]))
		self._chaboche_table = chaboche_table
		self._nb_chpar = chaboche_table.shape[0]
		return

	def sum_chaboche_terms(self, dgamma, back):
		sum_back, hat_back = np.zeros_like(back[0, ...]), np.zeros_like(back[0, ...])
		const_1, const_2 = np.zeros_like(dgamma), np.zeros_like(dgamma)

		for i in range(self._nb_chpar):
			[c, d] = self._chaboche_table[i, :]
			term = 1 / (1 + d * dgamma)
			sum_back += back[i, ...] / term
			hat_back += d * back[i, ...] / term**2
			const_1 += c * term
			const_2 += c / term**2
		return sum_back, hat_back, const_1, const_2

	def update_back_stress(self, idx_scalar, back_n0, back_n1, normal, dgamma, is_univariational=True):
		for i in range(self._nb_chpar):
			[c, d] = self._chaboche_table[i, :]
			idx = (slice(i), slice(None), slice(None), *idx_scalar)
			if is_univariational:
				back_n1[idx] = (back_n0[idx] + c * normal * dgamma) / (1. + d * dgamma)
			else:
				back_n1[idx] = (back_n0[idx] + np.sqrt(1.5) * c * normal * dgamma) / (1. + d * dgamma)
		return

class plasticity(material):

	def __init__(self, mat_args:dict):
		super().__init__()
		self._initialize_properties(mat_args)
		self._initialize_hardening(mat_args)
		return

	def _initialize_properties(self, mat_args:dict):
		self.elastic_modulus = mat_args.get('elastic_modulus')
		self.poisson_ratio = mat_args.get('poisson_ratio', 0.0)
		self.elastic_limit = mat_args.get('elastic_limit', 1.e15)
		self.lame_lambda = self.poisson_ratio * self.elastic_modulus / ((1 + self.poisson_ratio) * (1 - 2 * self.poisson_ratio))
		self.lame_mu = self.elastic_modulus / (2 * (1 + self.poisson_ratio))
		return

	def _initialize_hardening(self, mat_args:dict):
		iso_args = mat_args.get('iso_hardening', {})
		self.isotropic_hardening = isotropic_hardening(self.elastic_limit, iso_args)

		kine_args = mat_args.get('kine_hardening', {})
		self.kinematic_hardening = kinematic_hardening(kine_args)
		self._activated_plasticity = False if (len(iso_args) == 0 and len(kine_args) == 0) else True
		return

	def set_linear_elastic_tensor(self):
		pass

	def return_mapping(self):
		pass

class J2plasticity1d(plasticity):

	def __init__(self, mat_args:dict):
		super().__init__(mat_args=mat_args)
		return

	def set_linear_elastic_tensor(self, shape, nbvars):
		assert nbvars == 1, 'Size problem'
		if np.isscalar(shape): shape = np.array([shape], dtype=int)
		tensor = self.elastic_modulus*np.ones((nbvars, nbvars, nbvars, nbvars, *shape))
		return tensor

	def eval_elastic_stress(self, strain):
		stress = self.elastic_modulus*strain
		return stress

	def _prepare_parameters(self, stress_trial, back_n0, plseq_n0, max_iter=50, threshold=1e-8):
		dgamma = np.zeros_like(plseq_n0); plseq_n1 = np.copy(plseq_n0); theta = np.zeros_like(plseq_n0)
		for k in range(max_iter):
			sum_back, hat_back, const_1, const_2 = self.kinematic_hardening.sum_chaboche_terms(dgamma, back_n0)
			shifted_stress = stress_trial - sum_back
			norm_shifted = np.ravel(np.abs(shifted_stress))

			fun_yield = (
				norm_shifted
				- (self.elastic_modulus + const_1) * dgamma
				- self.isotropic_hardening.iso_hardening_function(plseq_n1)
			)
			res = np.linalg.norm(fun_yield)
			if k == 0:
				res_ref = res
			if res <= max([threshold * res_ref, 1e-12]):
				break

			normal = np.sign(shifted_stress)
			ders_fun_yield = (
				compute_double_contraction(normal, hat_back)
				- (self.elastic_modulus + const_2)
				- self.isotropic_hardening.iso_dershardening_function(plseq_n1)
			)
			dgamma -= fun_yield / ders_fun_yield
			plseq_n1 = plseq_n0 + dgamma
			theta = -self.elastic_modulus / ders_fun_yield

		return dgamma, hat_back, normal, theta

	def return_mapping(self, strain_n1, old_plastic_vars:dict, threshold=1e-8, update_tangent=True):
		""" Return mapping algorithm for multidimensional rate-independent plasticity. """

		assert np.ndim(strain_n1) > 2, "At least 3d array"
		assert np.shape(strain_n1)[0] == 1, "Only for 1d methods"
		strain_shape = tuple(np.shape(strain_n1)[2:])
		plasticstrain_n0 = old_plastic_vars.get('plastic_strain', np.zeros_like(strain_n1))
		plseq_n0 = old_plastic_vars.get('plastic_equivalent', np.zeros(shape=strain_shape))
		back_n0 = old_plastic_vars.get('back_stress', np.zeros(shape=(self.kinematic_hardening._nb_chpar, 1, 1, *strain_shape)))
		new_plastic_vars = {}

		# Compute trial stress
		strain_trial = strain_n1 - plasticstrain_n0
		stress_trial = self.eval_elastic_stress(strain_trial)

		# Compute shifted stress
		vonmises_trial = np.ravel(stress_trial - np.sum(back_n0, axis=0))

		# Check yield status
		J2_trial = np.abs(vonmises_trial) - self.isotropic_hardening.iso_hardening_function(plseq_n0)
		stress_n1 = np.copy(stress_trial)
		plasticstrain_n1= np.copy(plasticstrain_n0); plseq_n1 = np.copy(plseq_n0); back_n1 = np.copy(back_n0)
		consistent_tangent = self.set_linear_elastic_tensor(strain_shape, nbvars=1)

		if np.any(J2_trial>threshold*self.elastic_limit):

			# Select the quadrature points
			idx_scalar = np.nonzero(J2_trial>threshold*self.elastic_limit)
			idx_ten2d = (slice(None), slice(None), *idx_scalar)
			idx_ten3d = (slice(None), slice(None), slice(None), *idx_scalar)

			# Compute plastic-strain increment
			dgamma, _, tmp_normal, tmp_theta = self._prepare_parameters(stress_trial[idx_ten2d],
																			back_n0[idx_ten3d],
																			plseq_n0[idx_scalar])

			# Update internal hardening variable
			plseq_n1[idx_scalar] += dgamma

			# Update stress
			stress_n1[idx_ten2d] -= self.elastic_modulus*dgamma*tmp_normal

			# Update plastic strain
			plasticstrain_n1[idx_ten2d] += dgamma*tmp_normal

			# Update backstress
			self.kinematic_hardening.update_back_stress(idx_scalar, back_n0, back_n1, tmp_normal, dgamma, is_univariational=True)

			# Update stiffness tensor
			if update_tangent:
				theta = np.zeros_like(J2_trial); theta[idx_scalar] = tmp_theta
				consistent_tangent[0, 0, 0, 0, ...] = self.elastic_modulus*(1 - theta)

		mech_args = {'consistent_tangent': consistent_tangent}
		new_plastic_vars = {'plastic_strain': plasticstrain_n1, 'plastic_equivalent': plseq_n1, 'back_stress': back_n1}

		return stress_n1, mech_args, new_plastic_vars

class J2plasticity3d(plasticity):

	def __init__(self, mat_args):
		super().__init__(mat_args=mat_args)
		return

	def set_linear_elastic_tensor(self, shape, nbvars):
		assert nbvars > 1, 'Size problem'
		if np.isscalar(shape): shape = np.array([shape], dtype=int)
		tensor = np.zeros((nbvars, nbvars, nbvars, nbvars, *shape))
		identity = np.identity(nbvars)
		for i in range(nbvars):
			for j in range(nbvars):
				for l in range(nbvars):
					for m in range(nbvars):
						tensor[i, j, l, m, ...] = (
										self.lame_lambda*identity[i, l]*identity[j, m]
										+ self.lame_mu*(identity[i, m]*identity[j, l] + identity[i, j]*identity[l, m])
										)
		return tensor

	def eval_elastic_stress(self, strain):
		trace_strain = compute_trace(strain)
		stress = 2 * self.lame_mu * strain
		for i in range(np.size(strain, axis=0)):
			stress[i, i, ...] += self.lame_lambda * trace_strain
		return stress

	def eval_von_mises_stress(self, stress):
		stress_dev = compute_deviatoric(stress)
		norm_stress_dev = np.sqrt(1.5)*compute_norm_tensor(stress_dev)
		return norm_stress_dev

	def _prepare_parameters(self, stress_trial, back_n0, plseq_n0, max_iter=50, threshold=1e-8):
		dgamma, plseq_n1 = np.zeros_like(plseq_n0), np.copy(plseq_n0)
		theta_2, theta_1 = np.zeros_like(plseq_n0), np.zeros_like(plseq_n0)

		for k in range(max_iter):
			sum_back, hat_back, const_1, const_2 = self.kinematic_hardening.sum_chaboche_terms(dgamma, back_n0)
			shifted_stress = compute_deviatoric(stress_trial - sum_back)
			norm_shifted = compute_norm_tensor(shifted_stress)

			fun_yield = (
				np.sqrt(1.5) * norm_shifted
				- 1.5 * (2 * self.lame_mu + const_1) * dgamma
				- self.isotropic_hardening.iso_hardening_function(plseq_n1)
			)
			res = np.linalg.norm(fun_yield)
			if k == 0:
				res_ref = res
			if res <= max([threshold * res_ref, 1e-12]):
				break

			normal = shifted_stress / norm_shifted
			ders_fun_yield = (
				np.sqrt(1.5) * compute_double_contraction(normal, hat_back)
				- 1.5 * (2 * self.lame_mu + const_2)
				- self.isotropic_hardening.iso_dershardening_function(plseq_n1)
			)
			dgamma -= fun_yield / ders_fun_yield
			plseq_n1 = plseq_n0 + dgamma
			theta_1 = -3 * self.lame_mu / ders_fun_yield
			theta_2 = 2 * self.lame_mu * dgamma * np.sqrt(1.5) / norm_shifted

		return dgamma, hat_back, normal, theta_1, theta_2

	def return_mapping(self, strain_n1, old_plastic_vars:dict, threshold=1e-8, update_tangent=True):
		""" Return mapping algorithm for multidimensional rate-independent plasticity. """

		assert np.ndim(strain_n1) > 2, "At least 3d array"
		assert np.shape(strain_n1)[0] == 3, "Only for 3d methods"
		strain_shape = tuple(np.shape(strain_n1)[2:])
		plasticstrain_n0 = old_plastic_vars.get('plastic_strain', np.zeros_like(strain_n1))
		plseq_n0 = old_plastic_vars.get('plastic_equivalent', np.zeros(shape=strain_shape))
		back_n0 = old_plastic_vars.get('back_stress', np.zeros(shape=(self.kinematic_hardening._nb_chpar, 3, 3, *strain_shape)))
		new_plastic_vars = {}

		# Compute trial stress
		strain_trial = strain_n1 - plasticstrain_n0
		stress_trial = self.eval_elastic_stress(strain_trial)

		# Compute shifted stress
		vonmises_trial = self.eval_von_mises_stress(stress_trial - np.sum(back_n0, axis=0))

		# Check yield status
		J2_trial = vonmises_trial - self.isotropic_hardening.iso_hardening_function(plseq_n0)
		stress_n1 = np.copy(stress_trial)
		plasticstrain_n1= np.copy(plasticstrain_n0); plseq_n1 = np.copy(plseq_n0); back_n1 = np.copy(back_n0)
		lame_lambda, lame_mu = self.lame_lambda*np.ones_like(J2_trial), self.lame_mu*np.ones_like(J2_trial)
		consistent_tangent = self.set_linear_elastic_tensor(strain_shape, nbvars=3)

		if np.any(J2_trial>threshold*self.elastic_limit):

			# Select the quadrature points
			idx_scalar = np.nonzero(J2_trial>threshold*self.elastic_limit)
			idx_ten2d = (slice(None), slice(None), *idx_scalar)
			idx_ten3d = (slice(None), slice(None), slice(None), *idx_scalar)

			# Compute plastic-strain increment
			dgamma, tmp_hatback, tmp_normal, theta_1, theta_2 = self._prepare_parameters(
																					stress_trial[idx_ten2d],
																					back_n0[idx_ten3d],
																					plseq_n0[idx_scalar])

			# Update internal hardening variable
			plseq_n1[idx_scalar] += dgamma

			# Update stress
			stress_n1[idx_ten2d] -= 2*self.lame_mu*np.sqrt(1.5)*dgamma*tmp_normal

			# Update plastic strain
			plasticstrain_n1[idx_ten2d] += np.sqrt(1.5)*dgamma*tmp_normal

			# Update backstress
			self.kinematic_hardening.update_back_stress(idx_scalar, back_n0, back_n1, tmp_normal, dgamma, is_univariational=False)

			# Update stiffness tensor
			if update_tangent:
				omega_1 = np.zeros_like(J2_trial); omega_1[idx_scalar] = -2*self.lame_mu*(theta_1 - theta_2)
				omega_2 = np.zeros_like(J2_trial); omega_2[idx_scalar] = -np.sqrt(2.0/3.0)*theta_1*theta_2
				normal = np.zeros(shape=(3, 3, *strain_shape)); normal[idx_ten2d] = tmp_normal
				hatback = np.zeros(shape=(3, 3, *strain_shape)); hatback[idx_ten2d] = tmp_hatback
				lame_lambda[idx_scalar] += 2.0/3.0*self.lame_mu*theta_2
				lame_mu[idx_scalar] -= self.lame_mu*theta_2
				identity = np.identity(3)

				for i in range(3):
					for j in range(3):
						for l in range(3):
							for m in range(3):
								consistent_tangent[i, j, l, m, ...] = (
													lame_lambda*identity[i, l]*identity[j, m]
													+ lame_mu*(identity[i, m]*identity[j, l] + identity[i, j]*identity[l, m])
													+ omega_1*(normal[i, l, ...]*normal[j, m, ...])
													+ omega_2*(hatback[i, l, ...]*normal[j, m, ...]
															- normal[i, l, ...]*hatback[j, m, ...])
													)

		mech_args = {'consistent_tangent': consistent_tangent}
		new_plastic_vars = {'plastic_strain': plasticstrain_n1, 'plastic_equivalent': plseq_n1, 'back_stress': back_n1}

		return stress_n1, mech_args, new_plastic_vars

