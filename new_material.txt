from .__init__ import *
from typing import Callable, Union, Tuple
from abc import ABC, abstractmethod


def compute_double_contraction(
    tensor_1: np.ndarray, tensor_2: np.ndarray
) -> np.ndarray:
    assert tensor_1.shape == tensor_2.shape, "Array shapes must match"
    return np.sum(tensor_1 * tensor_2, axis=(0, 1))


def compute_norm_tensor(tensor: np.ndarray) -> np.ndarray:
    return np.sqrt(compute_double_contraction(tensor, tensor))


def compute_trace(tensor: np.ndarray) -> np.ndarray:
    assert tensor.shape[0] == tensor.shape[1], "Tensor must be square"
    return sum(tensor[i, i, ...] for i in range(tensor.shape[0]))


def compute_deviatoric(tensor: np.ndarray) -> np.ndarray:
    assert tensor.shape[0] == tensor.shape[1], "Tensor must be square"
    trace: np.ndarray = compute_trace(tensor) / 3.0
    deviatoric: np.ndarray = np.zeros_like(tensor)
    for i in range(tensor.shape[0]):
        deviatoric[i, i, ...] = tensor[i, i, ...] - trace[...]
    return deviatoric


class material:

    def __init__(self):
        self._has_uniform_density: bool = False
        self.add_density(1.0, is_uniform=True)  # By default

    def set_scalar_property(
        self, inpt: Union[Callable, float], is_uniform: bool = False
    ) -> Callable:
        if is_uniform:
            if np.isscalar(inpt):
                func: Callable = lambda args: inpt * np.ones(
                    shape=args["shape_quadpts"]
                )
            elif callable(inpt):
                func: Callable = lambda args: inpt(args)
            else:
                raise Warning("Not implemented")
        else:
            assert callable(inpt), "Not implemented"
            func: Callable = lambda args: inpt(args)
        return func

    def set_tensor_property(
        self,
        inpt: Union[Callable, float, np.ndarray],
        shape_tensor: int = 2,
        is_uniform: bool = False,
    ) -> Callable:

        def broadcast(inpt: np.ndarray, shape_tensor: int, shape_quadpts: np.ndarray):
            tensor = np.zeros(shape=(shape_tensor, shape_tensor, *shape_quadpts))
            for i in range(shape_tensor):
                for j in range(shape_tensor):
                    tensor[i, j, ...] = inpt[i, j]
            return tensor

        if is_uniform:
            if np.isscalar(inpt):
                func: Callable = lambda args: broadcast(
                    inpt * np.eye(shape_tensor), shape_tensor, args["shape_quadpts"]
                )
            elif isinstance(inpt, np.ndarray):
                func: Callable = lambda args: broadcast(
                    inpt, shape_tensor, args["shape_quadpts"]
                )
            elif callable(inpt):
                func: Callable = lambda args: inpt(args)
            else:
                raise Warning("Not implemented")
        else:
            assert callable(inpt), "Not implemented"
            func: Callable = lambda args: inpt(args)
        return func

    def add_density(self, inpt: Union[Callable, float], is_uniform: bool):
        if is_uniform:
            self._has_uniform_density = True
        self.density: Callable = self.set_scalar_property(inpt, is_uniform=is_uniform)


class heat_transfer_mat(material):
    """
    In our work we consider nonlinar materials, i.e. its thermal properties
    could change depending on the position, temperature, etc.
    """

    def __init__(self):
        super().__init__()
        self.capacity: Union[Callable, None] = None
        self.conductivity: Union[Callable, None] = None
        self._has_uniform_capacity: bool = False
        self._has_uniform_conductivity: bool = False

    def add_capacity(self, inpt: Union[Callable, float], is_uniform: bool):
        if is_uniform:
            self._has_uniform_capacity = True
        self.capacity = self.set_scalar_property(inpt, is_uniform=is_uniform)

    def add_conductivity(
        self,
        inpt: Union[Callable, float, np.ndarray],
        is_uniform: bool,
        shape_tensor: int,
    ):
        if is_uniform:
            self._has_uniform_conductivity = True
        self.conductivity = self.set_tensor_property(
            inpt, shape_tensor=shape_tensor, is_uniform=is_uniform
        )

    def add_ders_capacity(self, inpt: Union[Callable, float], is_uniform: bool):
        self.ders_capacity = self.set_scalar_property(inpt, is_uniform=is_uniform)

    def add_ders_conductivity(
        self,
        inpt: Union[Callable, float, np.ndarray],
        is_uniform: bool,
        shape_tensor: int,
    ):
        self.ders_conductivity = self.set_tensor_property(
            inpt, shape_tensor=shape_tensor, is_uniform=is_uniform
        )


class isotropic_hardening:
    def __init__(self, elastic_limit: float, iso_args: dict):
        self.elas_limit: float = elastic_limit
        self.iso_hardening_function, self.iso_dershardening_function = (
            self._select_model(iso_args)
        )

    def _select_model(self, iso_args: dict) -> Tuple[Callable, Callable]:
        models = {
            "none": self._model_none,
            "linear": self._model_linear,
            "swift": self._model_swift,
            "voce": self._model_voce,
        }
        model_name = str(iso_args.get("name", "none")).lower()
        if model_name not in models:
            raise ValueError("Unknown hardening model")
        return models[model_name](iso_args)

    def _model_none(self, args: dict) -> Tuple[Callable, Callable]:
        return lambda a: 1e8 * self.elas_limit * np.ones_like(
            a
        ), lambda a: np.zeros_like(a)

    def _model_linear(self, args: dict) -> Tuple[Callable, Callable]:
        Eiso = args.get("Eiso")
        return lambda a: self.elas_limit + Eiso * a, lambda a: Eiso * np.ones_like(a)

    def _model_swift(self, args: dict) -> Tuple[Callable, Callable]:
        e0, n = args.get("e0"), args.get("n")
        return lambda a: self.elas_limit * (
            1 + a / e0
        ) ** n, lambda a: self.elas_limit * n / e0 * (1 + a / e0) ** (n - 1)

    def _model_voce(self, args: dict) -> Tuple[Callable, Callable]:
        ssat, beta = args.get("ssat"), args.get("beta")
        return lambda a: self.elas_limit + ssat * (
            1 - np.exp(-beta * a)
        ), lambda a: ssat * beta * np.exp(-beta * a)


class kinematic_hardening:
    def __init__(self, kine_args: dict):
        chaboche_table: np.ndarray = np.atleast_2d(
            kine_args.get("parameters", [[0, 0]])
        )
        self._chaboche_table = chaboche_table
        self._nb_chpar = chaboche_table.shape[0]

    def sum_chaboche_terms(
        self, dgamma: np.ndarray, back: np.ndarray
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        sum_back, hat_back = np.zeros_like(back[0, ...]), np.zeros_like(back[0, ...])
        const_1, const_2 = np.zeros_like(dgamma), np.zeros_like(dgamma)

        for i in range(self._nb_chpar):
            [c, d] = self._chaboche_table[i, :]
            term = 1 / (1 + d * dgamma)
            sum_back += back[i, ...] / term
            hat_back += d * back[i, ...] / term**2
            const_1 += c * term
            const_2 += c / term**2
        return sum_back, hat_back, const_1, const_2

    def update_back_stress(
        self,
        idx_scalar: np.ndarray,
        back_n0: np.ndarray,
        back_n1: np.ndarray,
        normal: np.ndarray,
        dgamma: np.ndarray,
        is_univariational: bool = True,
    ):
        for i in range(self._nb_chpar):
            [c, d] = self._chaboche_table[i, :]
            idx = (slice(i), slice(None), slice(None), *idx_scalar)
            if is_univariational:
                back_n1[idx] = (back_n0[idx] + c * normal * dgamma) / (1.0 + d * dgamma)
            else:
                back_n1[idx] = (back_n0[idx] + np.sqrt(1.5) * c * normal * dgamma) / (
                    1.0 + d * dgamma
                )


class plasticity(material, ABC):

    max_iter: int = 50
    threshold: float = 1e-8

    def __init__(self, mat_args: dict):
        super().__init__()
        self._initialize_properties(mat_args)
        self._initialize_hardening(mat_args)

    def _initialize_properties(self, mat_args: dict):
        self.elastic_modulus: float = mat_args.get("elastic_modulus", 0.0)
        self.poisson_ratio: float = mat_args.get("poisson_ratio", 0.0)
        self.elastic_limit: float = mat_args.get("elastic_limit", 1.0e15)
        self.lame_lambda = (
            self.poisson_ratio
            * self.elastic_modulus
            / ((1 + self.poisson_ratio) * (1 - 2 * self.poisson_ratio))
        )
        self.lame_mu = self.elastic_modulus / (2 * (1 + self.poisson_ratio))

    def _initialize_hardening(self, mat_args: dict):
        iso_args = mat_args.get("iso_hardening", {})
        self.isotropic_hardening = isotropic_hardening(self.elastic_limit, iso_args)

        kine_args = mat_args.get("kine_hardening", {})
        self.kinematic_hardening = kinematic_hardening(kine_args)
        self._activated_plasticity = (
            False if (len(iso_args) == 0 and len(kine_args) == 0) else True
        )

    @abstractmethod
    def eval_elastic_stress(self):
        pass

    @abstractmethod
    def set_linear_elastic_tensor(self):
        pass

    @abstractmethod
    def return_mapping(self):
        pass


class J2plasticity1d(plasticity):

    def __init__(self, mat_args: dict):
        super().__init__(mat_args=mat_args)

    def set_linear_elastic_tensor(self, shape: Union[int, list], nbvars: int):
        assert nbvars == 1, "Size problem"
        if np.isscalar(shape):
            shape = np.array([shape], dtype=int)
        tensor = self.elastic_modulus * np.ones(
            (nbvars, nbvars, nbvars, nbvars, *shape)
        )
        return tensor

    def eval_elastic_stress(self, strain: np.ndarray) -> np.ndarray:
        stress = self.elastic_modulus * strain
        return stress

    def _prepare_parameters(
        self,
        stress_trial: np.ndarray,
        back_n0: np.ndarray,
        plseq_n0: np.ndarray,
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        dgamma = np.zeros_like(plseq_n0)
        plseq_n1 = np.copy(plseq_n0)
        theta = np.zeros_like(plseq_n0)
        for k in range(super().max_iter):
            sum_back, hat_back, const_1, const_2 = (
                self.kinematic_hardening.sum_chaboche_terms(dgamma, back_n0)
            )
            shifted_stress = stress_trial - sum_back
            norm_shifted = np.ravel(np.abs(shifted_stress))

            fun_yield = (
                norm_shifted
                - (self.elastic_modulus + const_1) * dgamma
                - self.isotropic_hardening.iso_hardening_function(plseq_n1)
            )
            res = np.linalg.norm(fun_yield)
            if k == 0:
                res_ref = res
            if res <= max([super().threshold * res_ref, 1e-12]):
                break

            normal = np.sign(shifted_stress)
            ders_fun_yield = (
                compute_double_contraction(normal, hat_back)
                - (self.elastic_modulus + const_2)
                - self.isotropic_hardening.iso_dershardening_function(plseq_n1)
            )
            dgamma -= fun_yield / ders_fun_yield
            plseq_n1 = plseq_n0 + dgamma
            theta = -self.elastic_modulus / ders_fun_yield

        return dgamma, hat_back, normal, theta

    def return_mapping(
        self, strain_n1: np.ndarray, old_plastic_vars: dict, update_tangent: bool = True
    ) -> Tuple[np.ndarray, dict, dict]:
        """Return mapping algorithm for multidimensional rate-independent plasticity."""

        assert np.ndim(strain_n1) > 2, "At least 3d array"
        assert np.shape(strain_n1)[0] == 1, "Only for 1d methods"
        strain_shape = tuple(np.shape(strain_n1)[2:])
        plasticstrain_n0 = old_plastic_vars.get(
            "plastic_strain", np.zeros_like(strain_n1)
        )
        plseq_n0 = old_plastic_vars.get(
            "plastic_equivalent", np.zeros(shape=strain_shape)
        )
        back_n0 = old_plastic_vars.get(
            "back_stress",
            np.zeros(shape=(self.kinematic_hardening._nb_chpar, 1, 1, *strain_shape)),
        )
        new_plastic_vars = {}

        # Compute trial stress
        strain_trial = strain_n1 - plasticstrain_n0
        stress_trial = self.eval_elastic_stress(strain_trial)

        # Compute shifted stress
        vonmises_trial = np.ravel(stress_trial - np.sum(back_n0, axis=0))

        # Check yield status
        J2_trial = np.abs(
            vonmises_trial
        ) - self.isotropic_hardening.iso_hardening_function(plseq_n0)
        stress_n1 = np.copy(stress_trial)
        plasticstrain_n1 = np.copy(plasticstrain_n0)
        plseq_n1 = np.copy(plseq_n0)
        back_n1 = np.copy(back_n0)
        consistent_tangent = self.set_linear_elastic_tensor(strain_shape, nbvars=1)

        if np.any(J2_trial > super().threshold * self.elastic_limit):

            # Select the quadrature points
            idx_scalar = np.nonzero(J2_trial > super().threshold * self.elastic_limit)
            idx_ten2d = (slice(None), slice(None), *idx_scalar)
            idx_ten3d = (slice(None), slice(None), slice(None), *idx_scalar)

            # Compute plastic-strain increment
            dgamma, _, tmp_normal, tmp_theta = self._prepare_parameters(
                stress_trial[idx_ten2d], back_n0[idx_ten3d], plseq_n0[idx_scalar]
            )

            # Update internal hardening variable
            plseq_n1[idx_scalar] += dgamma

            # Update stress
            stress_n1[idx_ten2d] -= self.elastic_modulus * dgamma * tmp_normal

            # Update plastic strain
            plasticstrain_n1[idx_ten2d] += dgamma * tmp_normal

            # Update backstress
            self.kinematic_hardening.update_back_stress(
                idx_scalar, back_n0, back_n1, tmp_normal, dgamma, is_univariational=True
            )

            # Update stiffness tensor
            if update_tangent:
                theta = np.zeros_like(J2_trial)
                theta[idx_scalar] = tmp_theta
                consistent_tangent[0, 0, 0, 0, ...] = self.elastic_modulus * (1 - theta)

        mech_args = {"consistent_tangent": consistent_tangent}
        new_plastic_vars = {
            "plastic_strain": plasticstrain_n1,
            "plastic_equivalent": plseq_n1,
            "back_stress": back_n1,
        }

        return stress_n1, mech_args, new_plastic_vars


class J2plasticity3d(plasticity):

    def __init__(self, mat_args: dict):
        super().__init__(mat_args=mat_args)

    def set_linear_elastic_tensor(
        self, shape: Union[int, list], nbvars: int
    ) -> np.ndarray:
        assert nbvars > 1, "Size problem"
        if np.isscalar(shape):
            shape = np.array([shape], dtype=int)
        tensor = np.zeros((nbvars, nbvars, nbvars, nbvars, *shape))
        identity = np.identity(nbvars)
        indices = np.indices((nbvars, nbvars, nbvars, nbvars), dtype=int)
        for i, j, l, m in zip(*[arr.flatten() for arr in indices]):
            tensor[i, j, l, m, ...] = self.lame_lambda * identity[i, l] * identity[
                j, m
            ] + self.lame_mu * (
                identity[i, m] * identity[j, l] + identity[i, j] * identity[l, m]
            )
        return tensor

    def eval_elastic_stress(self, strain: np.ndarray) -> np.ndarray:
        trace_strain = compute_trace(strain)
        stress = 2 * self.lame_mu * strain
        for i in range(strain.shape[0]):
            stress[i, i, ...] += self.lame_lambda * trace_strain
        return stress

    def eval_von_mises_stress(self, stress: np.ndarray) -> np.ndarray:
        stress_dev = compute_deviatoric(stress)
        stress_vm = np.sqrt(1.5) * compute_norm_tensor(stress_dev)
        return stress_vm

    def _prepare_parameters(
        self,
        stress_trial: np.ndarray,
        back_n0: np.ndarray,
        plseq_n0: np.ndarray,
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
        dgamma, plseq_n1 = np.zeros_like(plseq_n0), np.copy(plseq_n0)
        theta_2, theta_1 = np.zeros_like(plseq_n0), np.zeros_like(plseq_n0)

        for k in range(super().max_iter):
            sum_back, hat_back, const_1, const_2 = (
                self.kinematic_hardening.sum_chaboche_terms(dgamma, back_n0)
            )
            shifted_stress = compute_deviatoric(stress_trial - sum_back)
            norm_shifted = compute_norm_tensor(shifted_stress)

            fun_yield = (
                np.sqrt(1.5) * norm_shifted
                - 1.5 * (2 * self.lame_mu + const_1) * dgamma
                - self.isotropic_hardening.iso_hardening_function(plseq_n1)
            )
            res = np.linalg.norm(fun_yield)
            if k == 0:
                res_ref = res
            if res <= max([super().threshold * res_ref, 1e-12]):
                break

            normal = shifted_stress / norm_shifted
            ders_fun_yield = (
                np.sqrt(1.5) * compute_double_contraction(normal, hat_back)
                - 1.5 * (2 * self.lame_mu + const_2)
                - self.isotropic_hardening.iso_dershardening_function(plseq_n1)
            )
            dgamma -= fun_yield / ders_fun_yield
            plseq_n1 = plseq_n0 + dgamma
            theta_1 = -3 * self.lame_mu / ders_fun_yield
            theta_2 = 2 * self.lame_mu * dgamma * np.sqrt(1.5) / norm_shifted

        return dgamma, hat_back, normal, theta_1, theta_2

    def return_mapping(
        self, strain_n1: np.ndarray, old_plastic_vars: dict, update_tangent: bool = True
    ) -> Tuple[np.ndarray, dict, dict]:
        """Return mapping algorithm for multidimensional rate-independent plasticity."""

        assert np.ndim(strain_n1) > 2, "At least 3d array"
        assert np.shape(strain_n1)[0] == 3, "Only for 3d methods"
        strain_shape = tuple(np.shape(strain_n1)[2:])
        plasticstrain_n0 = old_plastic_vars.get(
            "plastic_strain", np.zeros_like(strain_n1)
        )
        plseq_n0 = old_plastic_vars.get(
            "plastic_equivalent", np.zeros(shape=strain_shape)
        )
        back_n0 = old_plastic_vars.get(
            "back_stress",
            np.zeros(shape=(self.kinematic_hardening._nb_chpar, 3, 3, *strain_shape)),
        )
        new_plastic_vars = {}

        # Compute trial stress
        strain_trial = strain_n1 - plasticstrain_n0
        stress_trial = self.eval_elastic_stress(strain_trial)

        # Compute shifted stress
        vonmises_trial = self.eval_von_mises_stress(
            stress_trial - np.sum(back_n0, axis=0)
        )

        # Check yield status
        J2_trial = vonmises_trial - self.isotropic_hardening.iso_hardening_function(
            plseq_n0
        )
        stress_n1 = np.copy(stress_trial)
        plasticstrain_n1 = np.copy(plasticstrain_n0)
        plseq_n1 = np.copy(plseq_n0)
        back_n1 = np.copy(back_n0)
        lame_lambda, lame_mu = self.lame_lambda * np.ones_like(
            J2_trial
        ), self.lame_mu * np.ones_like(J2_trial)
        consistent_tangent = self.set_linear_elastic_tensor(strain_shape, nbvars=3)

        if np.any(J2_trial > super().threshold * self.elastic_limit):

            # Select the quadrature points
            idx_scalar = np.nonzero(J2_trial > super().threshold * self.elastic_limit)
            idx_ten2d = (slice(None), slice(None), *idx_scalar)
            idx_ten3d = (slice(None), slice(None), slice(None), *idx_scalar)

            # Compute plastic-strain increment
            dgamma, tmp_hatback, tmp_normal, theta_1, theta_2 = (
                self._prepare_parameters(
                    stress_trial[idx_ten2d], back_n0[idx_ten3d], plseq_n0[idx_scalar]
                )
            )

            # Update internal hardening variable
            plseq_n1[idx_scalar] += dgamma

            # Update stress
            stress_n1[idx_ten2d] -= (
                2 * self.lame_mu * np.sqrt(1.5) * dgamma * tmp_normal
            )

            # Update plastic strain
            plasticstrain_n1[idx_ten2d] += np.sqrt(1.5) * dgamma * tmp_normal

            # Update backstress
            self.kinematic_hardening.update_back_stress(
                idx_scalar,
                back_n0,
                back_n1,
                tmp_normal,
                dgamma,
                is_univariational=False,
            )

            # Update stiffness tensor
            if update_tangent:
                omega_1 = np.zeros_like(J2_trial)
                omega_1[idx_scalar] = -2 * self.lame_mu * (theta_1 - theta_2)
                omega_2 = np.zeros_like(J2_trial)
                omega_2[idx_scalar] = -np.sqrt(2.0 / 3.0) * theta_1 * theta_2
                normal = np.zeros(shape=(3, 3, *strain_shape))
                normal[idx_ten2d] = tmp_normal
                hatback = np.zeros(shape=(3, 3, *strain_shape))
                hatback[idx_ten2d] = tmp_hatback
                lame_lambda[idx_scalar] += 2.0 / 3.0 * self.lame_mu * theta_2
                lame_mu[idx_scalar] -= self.lame_mu * theta_2
                identity = np.identity(3)
                indices = np.indices((3, 3, 3, 3), dtype=int)
                for i, j, l, m in zip(*[arr.flatten() for arr in indices]):
                    consistent_tangent[i, j, l, m, ...] = (
                        lame_lambda * identity[i, l] * identity[j, m]
                        + lame_mu
                        * (
                            identity[i, m] * identity[j, l]
                            + identity[i, j] * identity[l, m]
                        )
                        + omega_1 * (normal[i, l, ...] * normal[j, m, ...])
                        + omega_2
                        * (
                            hatback[i, l, ...] * normal[j, m, ...]
                            - normal[i, l, ...] * hatback[j, m, ...]
                        )
                    )

        mech_args = {"consistent_tangent": consistent_tangent}
        new_plastic_vars = {
            "plastic_strain": plasticstrain_n1,
            "plastic_equivalent": plseq_n1,
            "back_stress": back_n1,
        }

        return stress_n1, mech_args, new_plastic_vars

